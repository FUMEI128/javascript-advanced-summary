函数执行的过程内存的变化

一，总结：
1，函数定义的时候发生了什么？，
此时会生成一个arguments对象
确定了函数的[[scope]]属性（里面记录的是它的所有的父级变量对象vo）

2，函数执行时发生了什么？
形成函数执行上下文{
	VO（变量对象），
	作用域链：（由它的vo和[[scope]]属性构成）（其实就是他自己的vo加上它的所有父级的vo构成），
	this指向
}

注意事项：在代码执行之前会发生变量提升代码的编译阶段
1）函数声明优先提升
2）变量声明提升
3）当函数声明重复时候，会发生覆盖，当变量声明发生重复的时候，会忽略重复的变量声明

3，函数执行结束后发生了什么？
函数执行结束后，开始销毁执行上下，执行上下文回收阶段


二，小知识点
1，作用域：全局作用域，函数作用域（局部作用域），块作用域
2，作用域的工作模型：词法作用域，动态作用域
词法作用域：由函数的书写位置决定，于带哦用位置无关
动态作用域：由调用位置决定，不关心变量和函数的书写位置
现在我们用的就是词法作用域，执行过程是通过作用域链来一级一级查找的，
而动态作用域是找到函数的位置，从此处向上一行一行的代码。

注意：通过new Function创建的函数不遵从静态词法作用域，总是在全局作用域中执行。
3，变量函数访问规则
沿着作用域链从里向外查找，查找只会找一级标识符（对于函数来说，函数名是一级标题，不会访问到它的内部）
